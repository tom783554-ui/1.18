name: Codex PR Auto-Merge Retry

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  codex-automerge-retry:
    runs-on: ubuntu-latest
    steps:
      - name: Retry merge for Codex PRs
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const { data: pulls } = await github.rest.pulls.list({
              owner,
              repo,
              state: "open",
              per_page: 100,
            });

            const codexPulls = pulls.filter((pr) => {
              const authorLogin = pr.user?.login || "";
              const headRef = pr.head?.ref || "";
              const title = pr.title || "";
              return /codex|openai/i.test(authorLogin)
                || /codex/i.test(headRef)
                || /codex/i.test(title);
            });

            if (codexPulls.length === 0) {
              core.info("No Codex/OpenAI PRs found.");
              return;
            }

            for (const pr of codexPulls) {
              if (pr.draft) {
                core.info(`PR #${pr.number} is draft; skipping.`);
                continue;
              }

              const headSha = pr.head.sha;
              const { data: combinedStatus } = await github.rest.repos.getCombinedStatusForRef({
                owner,
                repo,
                ref: headSha,
              });
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: headSha,
              });

              const statusState = combinedStatus.state;
              const incompleteCheck = checkRuns.check_runs.find(
                (run) => run.status !== "completed"
              );
              const failedCheck = checkRuns.check_runs.find(
                (run) => !["success", "neutral", "skipped"].includes(run.conclusion)
              );
              const checksGreen = statusState === "success" && !incompleteCheck && !failedCheck;

              const { data: freshPr } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pr.number,
              });

              if (!checksGreen) {
                const reason = incompleteCheck
                  ? `checks not complete (example: ${incompleteCheck.name})`
                  : failedCheck
                    ? `checks not successful (example: ${failedCheck.name})`
                    : `combined status=${statusState}`;
                core.info(`PR #${pr.number} skipping merge because ${reason}.`);
                continue;
              }

              if (!freshPr.mergeable) {
                core.info(`PR #${pr.number} skipping merge because mergeable=${freshPr.mergeable}, mergeable_state=${freshPr.mergeable_state}.`);
                continue;
              }

              if (!["clean", "unstable", "has_hooks"].includes(freshPr.mergeable_state)) {
                core.info(`PR #${pr.number} skipping merge because mergeable_state=${freshPr.mergeable_state}.`);
                continue;
              }

              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: pr.number,
                  merge_method: "squash",
                });
                core.info(`PR #${pr.number} merged via scheduled retry.`);
              } catch (error) {
                core.warning(`PR #${pr.number} merge failed: ${error.message}`);
              }
            }
