name: Codex PR Auto-Approve and Auto-Merge

on:
  pull_request_target:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: write
  pull-requests: write
  checks: read

concurrency:
  group: codex-pr-automerge-${{ github.event.pull_request.number }}
  cancel-in-progress: false

jobs:
  codex-automerge:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-approve and auto-merge Codex PRs
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;

            const { data: pr } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber,
            });

            if (pr.draft) {
              core.info("PR is draft; skipping.");
              return;
            }

            const authorLogin = pr.user?.login || "";
            const headRef = pr.head?.ref || "";
            const title = pr.title || "";
            const isCodex = /codex|openai/i.test(authorLogin)
              || /codex/i.test(headRef)
              || /codex/i.test(title);

            if (!isCodex) {
              core.info("PR does not appear to be from Codex/OpenAI; skipping.");
              return;
            }

            try {
              await github.rest.pulls.createReview({
                owner,
                repo,
                pull_number: prNumber,
                event: "APPROVE",
                body: "Auto-approve Codex PR.",
              });
              core.info("Auto-approval submitted.");
            } catch (error) {
              core.warning(`Unable to auto-approve: ${error.message}`);
            }

            let autoMergeEnabled = false;
            try {
              await github.graphql(
                `mutation($pullRequestId: ID!) {
                  enablePullRequestAutoMerge(input: {pullRequestId: $pullRequestId, mergeMethod: SQUASH}) {
                    pullRequest {
                      number
                      autoMergeRequest {
                        enabledAt
                      }
                    }
                  }
                }`,
                { pullRequestId: pr.node_id }
              );
              core.info("Auto-merge enabled.");
              autoMergeEnabled = true;
            } catch (error) {
              core.warning(`Unable to enable auto-merge: ${error.message}`);
            }

            if (autoMergeEnabled) {
              return;
            }

            const headSha = pr.head.sha;
            const { data: combinedStatus } = await github.rest.repos.getCombinedStatusForRef({
              owner,
              repo,
              ref: headSha,
            });
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner,
              repo,
              ref: headSha,
            });

            const statusState = combinedStatus.state;
            const incompleteCheck = checkRuns.check_runs.find(
              (run) => run.status !== "completed"
            );
            const failedCheck = checkRuns.check_runs.find(
              (run) => !["success", "neutral", "skipped"].includes(run.conclusion)
            );

            const checksGreen = statusState === "success" && !incompleteCheck && !failedCheck;

            const { data: freshPr } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber,
            });

            if (!checksGreen) {
              const reason = incompleteCheck
                ? `checks not complete (example: ${incompleteCheck.name})`
                : failedCheck
                  ? `checks not successful (example: ${failedCheck.name})`
                  : `combined status=${statusState}`;
              core.info(`Skipping merge because ${reason}.`);
              return;
            }

            if (!freshPr.mergeable) {
              core.info(`Skipping merge because mergeable=${freshPr.mergeable}, mergeable_state=${freshPr.mergeable_state}.`);
              return;
            }

            if (!["clean", "unstable", "has_hooks"].includes(freshPr.mergeable_state)) {
              core.info(`Skipping merge because mergeable_state=${freshPr.mergeable_state}.`);
              return;
            }

            try {
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: prNumber,
                merge_method: "squash",
              });
              core.info("Merged PR via fallback REST merge.");
            } catch (error) {
              core.warning(`Fallback merge failed: ${error.message}`);
            }
